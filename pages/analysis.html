<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>DESC</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
        <script src="js/scripts.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.8.0/Chart.min.js" crossorigin="anonymous"></script>

        <script src="https://cdn.jsdelivr.net/npm/simple-datatables@latest" crossorigin="anonymous"></script>


		<script src="https://code.jquery.com/jquery-3.4.1.min.js" crossorigin="anonymous"></script>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.form/4.2.2/jquery.form.min.js"></script>
		<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"></script>

        <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>

        <script src="https://cdn.datatables.net/1.10.20/js/jquery.dataTables.min.js" crossorigin="anonymous"></script>
        <script src="https://cdn.datatables.net/1.10.20/js/dataTables.bootstrap4.min.js" crossorigin="anonymous"></script>



		<script src="https://webgl2fundamentals.org/webgl/resources/webgl-utils.js"></script>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js" charset="utf-8"></script>

		<script src="https://d3js.org/d3.v5.min.js"></script>
		<script src="https://unpkg.com/d3-simple-slider"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.24.0/d3-legend.min.js"></script>
		<script src="http://ajax.cdnjs.com/ajax/libs/json2/20110223/json2.js"></script>
		<script src="d3-lasso.min.js"></script>
		<script src="KMEANS.js"></script>
		<script src="DBSCAN.js"></script>
		<script src="papaparse.min.js"></script>
		<script src="https://darshit-shah.github.io/d3.floatingScale.js"></script>

  <style>
    body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;margin:0;background:#000000;color:#E6E6E6}
    header{background:rgba(11, 11, 15, 0.95);backdrop-filter:blur(20px);border-bottom:1px solid rgba(255, 255, 255, 0.08);color:#E6E6E6;padding:10px 16px;font-weight:600}
    .wrap{padding:14px 16px;max-width:1200px;margin:0 auto}
    .card{background:rgba(255, 255, 255, 0.04);backdrop-filter:blur(20px);border:1px solid rgba(255, 255, 255, 0.08);border-radius:16px;padding:16px;margin-bottom:16px;transition:all 0.3s ease}
    .card:hover{background:rgba(255, 255, 255, 0.06);border-color:rgba(255, 255, 255, 0.12);box-shadow:0 8px 32px rgba(0, 0, 0, 0.4)}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .col{flex:1 1 420px;min-width:320px}
    label{display:block;font-size:12px;font-weight:700;margin-bottom:6px;color:#E6E6E6}
    input[type=text],select{width:100%;padding:8px 10px;border:1px solid rgba(255, 255, 255, 0.2);border-radius:8px;font-size:14px;box-sizing:border-box;background:rgba(255, 255, 255, 0.08);color:#E6E6E6}
    input[type=text]:focus,select:focus{outline:none;border-color:#479FFA;background:rgba(255, 255, 255, 0.12)}
    select option{background:#1a1a1a;color:#E6E6E6}
    button{padding:8px 12px;border:0;border-radius:8px;background:#479FFA;color:#fff;font-weight:700;cursor:pointer;transition:all 0.2s ease}
    button:hover{background:#5AAFFF}
    button:disabled{background:rgba(255, 255, 255, 0.2);cursor:default}
    .hint{font-size:12px;color:#868F97;margin-top:6px}
    .chips{display:flex;flex-wrap:wrap;gap:6px;margin-top:10px}
    .chip{background:rgba(71, 159, 250, 0.15);color:#479FFA;border:1px solid rgba(71, 159, 250, 0.3);border-radius:999px;padding:4px 10px;font-size:12px}
    .chip .x{margin-left:6px;color:#479FFA;cursor:pointer;font-weight:900}
    .chip .x:hover{color:#5AAFFF}
    .title{display:flex;align-items:baseline;gap:10px}
    .title h3{margin:0;font-size:15px;color:#E6E6E6}
    .title h2{color:#E6E6E6}
    .title span{font-size:12px;color:#868F97}
    svg text{font-family:inherit;fill:#E6E6E6}

.heatmaps-container{display:flex;flex-direction:column;gap:16px;}
#heatmap_tooltip{
  position:fixed;
  pointer-events:none;
  background:rgba(0,0,0,0.9);
  color:#fff;
  padding:6px 8px;
  border-radius:6px;
  font-size:12px;
  line-height:1.2;
  z-index:9999;
  display:none;
  max-width:320px;
  white-space:nowrap;
  border:1px solid rgba(255, 255, 255, 0.2);
}

</style>
</head>

<body>
<div id="heatmap_tooltip"></div>
<header>Gene Feature Analysis</header>

<div class="wrap">

  <div class="card">
    <div class="title">
      <h3>Add feature</h3>
    </div>

    <div class="row" style="align-items:end">
      <div class="col" style="flex:2 1 520px;min-width:340px">
        <label>Feature / Gene name</label>
                <select id="feature_name">
          <option value="" selected disabled>Select a feature…</option>
          <option value="Vtn">Vtn</option>
          <option value="Adgrl4">Adgrl4</option>
          <option value="Pglyrp1">Pglyrp1</option>
          <option value="Sostdc1">Sostdc1</option>
          <option value="C3">C3</option>
          <option value="Ankfn1">Ankfn1</option>
          <option value="Meig1">Meig1</option>
          <option value="Fras1">Fras1</option>
          <option value="Foxp2">Foxp2</option>
          <option value="Il1r1">Il1r1</option>
          <option value="Afap1l1">Afap1l1</option>
          <option value="Cdkn1a">Cdkn1a</option>
          <option value="2410004P03Rik">2410004P03Rik</option>
          <option value="Hsd11b1">Hsd11b1</option>
          <option value="Tns3">Tns3</option>
          <option value="Zmat4">Zmat4</option>
          <option value="Uaca">Uaca</option>
          <option value="Odf3b">Odf3b</option>
          <option value="Ets1">Ets1</option>
          <option value="Cfap54">Cfap54</option>
          <option value="Lef1">Lef1</option>
          <option value="Tmem163">Tmem163</option>
          <option value="Nnat">Nnat</option>
          <option value="Acer2">Acer2</option>
        </select>
        <div class="hint">
        </div>
      </div>
      <div class="col" style="flex:0 0 160px;min-width:160px">
        <button id="btn_add">Add feature</button>
      </div>
    </div>

    <div class="chips" id="feature_chips"></div>

    <div class="hint" style="margin-top:10px">
    </div>
  </div>


<div class="heatmaps-container">
  <div class="card">
    <h2>Hull heatmap</h2>
    <!-- <div class="subtle">用 convex hull 面積上色（每個 feature × dim 一格）。Hover 可看數值。</div> -->
    <div id="hull_heatmap"></div>
  </div>

  <div class="card">
    <h2>Cluster heatmap</h2>
    <!-- <div class="subtle">用 Leiden clustering 的 bounding box 面積上色。</div> -->
    <div id="cluster_heatmap"></div>
  </div>
</div>


<script>

const fd = 2;
const ld = 30;
const rds_name = "GSE161340.rds";
const rds_name_only = rds_name.replace(/\.rds$/i, "");
const ds_folder = `/data2/${rds_name_only}_${fd}_${ld}`;
const dim_path = `${ds_folder}/dimensions.csv`;

// how many dims to display (fd..ld inclusive)
const n_dims = (ld - fd + 1);

// UI sizes
const HM_W = 520, HM_H = 520;
const margin = {top: 70, right: 18, bottom: 30, left: 90};

// feature store: name - > cell id array
const featureCells = new Map();

// dimensions: [cell_index] -> [x1,y1,x2,y2,...] for dims fd..ld

// --- tooltip helpers ---
const _tip = document.getElementById("heatmap_tooltip");
function _showTip(text, evt){
  if(!_tip) return;
  _tip.textContent = text;
  _tip.style.display = "block";
  const x = (evt && evt.clientX != null) ? evt.clientX : 0;
  const y = (evt && evt.clientY != null) ? evt.clientY : 0;
  _tip.style.left = (x + 12) + "px";
  _tip.style.top  = (y + 12) + "px";
}
function _moveTip(evt){
  if(!_tip || _tip.style.display === "none") return;
  _tip.style.left = (evt.clientX + 12) + "px";
  _tip.style.top  = (evt.clientY + 12) + "px";
}
function _hideTip(){
  if(!_tip) return;
  _tip.style.display = "none";
}

let dimensions = null;
let nrow = 0;
let clusterings = null; // rows: one cell, cols: '2'..'30' Leiden labels

function loadDimensionsCSV() {
  return new Promise((resolve, reject) => {
    d3.csv(dim_path).then(rows => {
      if (!rows || rows.length === 0) return reject(new Error("dimensions.csv is empty"));
      // columns: row_col, x_fd, y_fd, x_fd+1, y_fd+1, ...
      const keys = Object.keys(rows[0]);
      const dimKeys = keys.slice(1); // skip row_col
      if (dimKeys.length < 2*n_dims) {
        console.warn("dimensions.csv columns:", dimKeys.length, "expected:", 2*n_dims);
      }
      dimensions = rows.map(r => dimKeys.map(k => +r[k]));
      nrow = dimensions.length;
      resolve();
    }).catch(reject);
  });
}


function loadClusteringsCSV() {
  return new Promise((resolve, reject) => {
    d3.csv(`${ds_folder}/clusterings.csv`).then(rows => {
      if (!rows || rows.length === 0) return reject(new Error("clusterings.csv is empty"));
      // Each row = one cell; columns are "2","3",...,"30"
      clusterings = rows.map(r => {
        const obj = {};
        for (const k of Object.keys(r)) obj[k] = +r[k];
        return obj;
      });
      resolve();
    }).catch(reject);
  });
}

function renderChips() {
  const el = document.getElementById("feature_chips");
  el.innerHTML = "";
  for (const name of featureCells.keys()) {
    const chip = document.createElement("span");
    chip.className = "chip";
    chip.textContent = name;
    const x = document.createElement("span");
    x.className = "x";
    x.textContent = "×";
    x.onclick = () => {
      featureCells.delete(name);
      renderChips();
      drawClusterHeatmap();
      drawHullHeatmap();
    };
    chip.appendChild(x);
    el.appendChild(chip);
  }
}

function parseDimsCellsROutput(txt) {
  // expected: "Vtn,1427 67 185 ..."
  const s = (txt || "").trim();
  if (!s.includes(",")) throw new Error("dims_cells.R output missing comma (expected 'Gene,ids...')");
  const [namePart, idsPart] = s.split(",", 2);
  const name = namePart.trim();
  const ids = idsPart.trim().split(/\s+/).filter(Boolean).map(x => parseInt(x, 10)).filter(Number.isFinite);
  return {name, ids};
}

async function loadCachedDimsCellsOutput(featureName) {
  const url = `${ds_folder}/feature_cache/${encodeURIComponent(featureName)}.txt`;
  const resp = await fetch(url, { cache: "no-store" });
  if (!resp.ok) throw new Error(`cache miss (${resp.status})`);
  return (await resp.text()).trim();
}

function computeBBoxAreas(featureName) {
  const ids = featureCells.get(featureName) || [];
  const areas = new Array(n_dims).fill(0);

  if (!dimensions || nrow === 0 || ids.length === 0) return areas;

  for (let di = 0; di < n_dims; di++) {
    const xIdx = 2*di;
    const yIdx = 2*di + 1;

    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    let any = false;

    for (let k=0; k<ids.length; k++) {
      const id = ids[k];
      if (id < 0 || id >= nrow) continue;
      const row = dimensions[id];
      const x = row[xIdx], y = row[yIdx];
      if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
      any = true;
      if (x < minX) minX = x;
      if (x > maxX) maxX = x;
      if (y < minY) minY = y;
      if (y > maxY) maxY = y;
    }
    if (any) areas[di] = Math.abs((maxX - minX) * (maxY - minY));
  }
  return areas;
}

function rowNormalizeBySum(arr) {
  const s = arr.reduce((a,b)=>a+(Number.isFinite(b)?b:0), 0);
  if (!s || s <= 0) return arr.map(_=>0);
  return arr.map(v => (Number.isFinite(v)? v/s : 0));
}


function drawClusterHeatmap() {
  const container = d3.select("#cluster_heatmap");
  container.selectAll("*").remove();

  if (!dimensions || !clusterings) {
    container.append("div").style("color","#666").style("font-size","12px").text("Loading dimensions/clusterings...");
    return;
  }

  // Collect all clusters that appear in any dim
  const clusterSet = new Set();
  for (let cell = 0; cell < nrow; cell++) {
    for (let di = 0; di < n_dims; di++) {
      const dim = String(fd + di);
      const c = clusterings[cell][dim];
      if (Number.isFinite(c)) clusterSet.add(c);
    }
  }
  const clusters = Array.from(clusterSet).sort((a,b)=>a-b);

  // Precompute bbox area per cluster per dim
  const areas = new Map();
  for (const c of clusters) areas.set(c, new Array(n_dims).fill(0));

  let globalMax = 0;

  for (let di = 0; di < n_dims; di++) {
    const dimNum = fd + di;
    const dimKey = String(dimNum);
    const xIdx = 2*di;
    const yIdx = 2*di + 1;

    // bbox accumulators per cluster
    const minX = new Map(), maxX = new Map(), minY = new Map(), maxY = new Map();
    const seen = new Set();

    for (let cell=0; cell<nrow; cell++){
      const c = clusterings[cell][dimKey];
      if (!Number.isFinite(c)) continue;
      const row = dimensions[cell];
      const x = row[xIdx], y = row[yIdx];
      if (!Number.isFinite(x) || !Number.isFinite(y)) continue;

      if (!seen.has(c)) {
        seen.add(c);
        minX.set(c, x); maxX.set(c, x);
        minY.set(c, y); maxY.set(c, y);
      } else {
        if (x < minX.get(c)) minX.set(c, x);
        if (x > maxX.get(c)) maxX.set(c, x);
        if (y < minY.get(c)) minY.set(c, y);
        if (y > maxY.get(c)) maxY.set(c, y);
      }
    }

    for (const c of seen) {
      const a = Math.abs((maxX.get(c) - minX.get(c)) * (maxY.get(c) - minY.get(c)));
      areas.get(c)[di] = a;
      if (a > globalMax) globalMax = a;
    }
  }

  // Build matrix
  const matrix = [];
  for (const c of clusters) {
    const arr = areas.get(c);
    for (let di=0; di<n_dims; di++) {
      const dim = fd + di;
      matrix.push({cluster: c, dim, v: arr[di]});
    }
  }

  // Layout: match hull heatmap small squares
  const cellSize = 26;
  const pad = 3;
  const W = margin.left + margin.right + n_dims * (cellSize + pad);
  const H = margin.top + margin.bottom + clusters.length * (cellSize + pad);

  const svg = container.append("svg").attr("width", W).attr("height", H);

  const xBand = d3.scaleBand()
    .domain(d3.range(fd, ld + 1))
    .range([margin.left, W - margin.right])
    .paddingInner(0.15);

  const yBand = d3.scaleBand()
    .domain(clusters)
    .range([margin.top, H - margin.bottom])
    .paddingInner(0.25);

  svg.append("text")
    .attr("x", margin.left)
    .attr("y", 18)
    .attr("font-size", 12)
    .attr("font-weight", 700)
    .text("Cluster heatmap (Leiden bbox area)");

  svg.append("text")
  .attr("x", (margin.left + W - margin.right) / 2)
  .attr("y", margin.top - 40)
  .attr("text-anchor", "middle")
  .attr("font-size", 12)
  .attr("font-weight", 600)
  .text("PCA dimension (PC2–PC30)");

  svg.append("g")
    .attr("transform", `translate(0,${margin.top - 6})`)
    .call(d3.axisTop(xBand).tickValues(d3.range(fd, ld + 1).filter(d => (d - fd) % 4 === 0)))
    .selectAll("text")
    .attr("font-size", 10);

  svg.append("text")
  .attr(
    "transform",
    `translate(${margin.left - 55}, ${(margin.top + H - margin.bottom) / 2}) rotate(-90)`
  )
  .attr("text-anchor", "middle")
  .attr("font-size", 12)
  .attr("font-weight", 600)
  .text("Leiden cluster ID");


  svg.append("g")
    .attr("transform", `translate(${margin.left - 6},0)`)
    .call(d3.axisLeft(yBand).tickValues(clusters.filter((_,i)=> i%2===0)))
    .selectAll("text")
    .attr("font-size", 10);

  // Stronger contrast: normalize then apply gamma (<1 boosts low/mid)
  const CLUSTER_GAMMA = 0.55;
  const color = d3.scaleSequential(d3.interpolateOranges).domain([0, 1]);

  svg.append("g")
    .selectAll("rect")
    .data(matrix)
    .enter()
    .append("rect")
    .attr("x", d => xBand(d.dim))
    .attr("y", d => yBand(d.cluster))
    .attr("width", xBand.bandwidth())
    .attr("height", yBand.bandwidth())
    .attr("rx", 4)
    .attr("fill", d => {
      const vn = (globalMax > 0) ? (d.v / globalMax) : 0;
      return color(Math.pow(vn, CLUSTER_GAMMA));
    })
    .on("mouseover", function(d){
      const e = (typeof d3 !== "undefined" && d3.event) ? d3.event : null;
      const vr = Number.isFinite(d.v) ? d.v : 0;
      const txt = `cluster ${d.cluster} | dim ${d.dim} | bbox(area): ${vr.toExponential(3)}`;
      _showTip(txt, e);
    })
    .on("mousemove", function(){
      const e = (typeof d3 !== "undefined" && d3.event) ? d3.event : null;
      if(e) _moveTip(e);
    })
    .on("mouseout", function(){ _hideTip(); });
}


function computeHullAreas(featureName) {
  // returns per-dim convex hull area in the original x/y coordinate space
  const ids = featureCells.get(featureName) || [];
  const areas = new Array(n_dims).fill(0);

  if (!dimensions || nrow === 0 || ids.length < 3) return areas;

  for (let di = 0; di < n_dims; di++) {
    const xIdx = 2 * di;
    const yIdx = 2 * di + 1;

    const pts = [];
    for (let k = 0; k < ids.length; k++) {
      const id = ids[k];
      if (id < 0 || id >= nrow) continue;
      const row = dimensions[id];
      const x = row[xIdx], y = row[yIdx];
      if (Number.isFinite(x) && Number.isFinite(y)) pts.push([x, y]);
    }

    if (pts.length >= 3) {
      const hull = d3.polygonHull(pts);
      if (hull && hull.length >= 3) {
        // d3.polygonArea can be negative depending on winding; use abs
        areas[di] = Math.abs(d3.polygonArea(hull));
      }
    }
  }

  return areas;
}

function drawHullHeatmap() {
  const container = d3.select("#hull_heatmap");
  container.selectAll("*").remove();

  const features = Array.from(featureCells.keys());
  if (!dimensions || features.length === 0) {
    container.append("div").style("color", "#666").style("font-size", "12px").text("Add at least one feature.");
    return;
  }

  // Precompute per-feature hull areas (RAW) for coloring (same as analysis.html)
  const hullRawMap = new Map();   // feature -> raw areas[]
  let globalMax = 0;

  for (const f of features) {
    const raw = computeHullAreas(f);
    hullRawMap.set(f, raw);
    const m = d3.max(raw) || 0;
    if (m > globalMax) globalMax = m;
  }

  const color = d3.scaleSequential(d3.interpolatePuBuGn)
    .domain([0, globalMax || 1e-9]);

  const cellSize = 26;
  const pad = 3;
  const W = margin.left + margin.right + n_dims * (cellSize + pad);
  const H = margin.top + margin.bottom + features.length * (cellSize + pad);

  const svg = container.append("svg").attr("width", W).attr("height", H);

  const xBand = d3.scaleBand()
    .domain(d3.range(fd, ld + 1))
    .range([margin.left, W - margin.right])
    .paddingInner(0.15);

  const yBand = d3.scaleBand()
    .domain(features)
    .range([margin.top, H - margin.bottom])
    .paddingInner(0.25);

  svg.append("text") // 圖標題
    .attr("x", margin.left)
    .attr("y", 18)
    .attr("font-size", 12)
    .attr("font-weight", 700)
    .text("Hull heatmap (convex hull)");

  svg.append("g") //X 軸（刻度）
    .attr("transform", `translate(0,${margin.top - 6})`)
    .call(d3.axisTop(xBand).tickValues(d3.range(fd, ld + 1).filter(d => (d - fd) % 4 === 0)))
    .selectAll("text")
    .attr("font-size", 10);

  svg.append("g") //Y 軸（刻度）
    .attr("transform", `translate(${margin.left - 6},0)`)
    .call(d3.axisLeft(yBand))
    .selectAll("text")
    .attr("font-size", 11);

  svg.append("text")
  .attr("x", (margin.left + W - margin.right) / 2)
  .attr("y", margin.top - 40)
  .attr("text-anchor", "middle")
  .attr("font-size", 12)
  .attr("font-weight", 600)
  .text("PCA dimension (PC2–PC30)");

  svg.append("text")
  .attr(
    "transform",
    `translate(${margin.left - 75}, ${(margin.top + H - margin.bottom) / 2}) rotate(-90)`
  )
  .attr("text-anchor", "middle")
  .attr("font-size", 12)
  .attr("font-weight", 600)
  .text("Feature / Gene");



  for (const f of features) {
    const ids = featureCells.get(f) || [];
    const raw = hullRawMap.get(f) || new Array(n_dims).fill(0);

    for (let di = 0; di < n_dims; di++) {
      const dim = fd + di;
      const gx = xBand(dim);
      const gy = yBand(f);
      if (gx == null || gy == null) continue;

      const g = svg.append("g").attr("transform", `translate(${gx},${gy})`);

      const cellDatum = { feature: f, dim, v_raw: raw[di], v_norm: (globalMax ? (raw[di] / globalMax) : 0) };

      g.append("rect")
        .datum(cellDatum)
        .attr("width", xBand.bandwidth())
        .attr("height", yBand.bandwidth())
        .attr("rx", 4)
        .attr("fill", color(raw[di]))
        .attr("opacity", 1)
        .on("mouseover", function(d) {
          const e = (typeof d3 !== "undefined" && d3.event) ? d3.event : null;
          const vn = Number.isFinite(d.v_norm) ? d.v_norm : 0;
          const vr = Number.isFinite(d.v_raw) ? d.v_raw : 0;
          const txt = `${d.feature} | dim ${d.dim} | hull(area): ${vr.toExponential(3)} | norm: ${vn.toFixed(4)}`;
          _showTip(txt, e);
        })
        .on("mousemove", function() {
          const e = (typeof d3 !== "undefined" && d3.event) ? d3.event : null;
          if (e) _moveTip(e);
        })
        .on("mouseout", function() { _hideTip(); });

      if (ids.length >= 3) {
        const xIdx = 2 * di, yIdx = 2 * di + 1;
        const pts = [];
        for (let k = 0; k < ids.length; k++) {
          const id = ids[k];
          if (id < 0 || id >= nrow) continue;
          const row = dimensions[id];
          const x = row[xIdx], y = row[yIdx];
          if (Number.isFinite(x) && Number.isFinite(y)) pts.push([x, y]);
        }
        if (pts.length >= 3) {
          const hull = d3.polygonHull(pts);
          if (hull && hull.length >= 3) {
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            hull.forEach(p => { minX = Math.min(minX, p[0]); maxX = Math.max(maxX, p[0]); minY = Math.min(minY, p[1]); maxY = Math.max(maxY, p[1]); });
            const sx = d3.scaleLinear().domain([minX, maxX]).range([4, xBand.bandwidth() - 4]);
            const sy = d3.scaleLinear().domain([minY, maxY]).range([yBand.bandwidth() - 4, 4]);
            const path = d3.line().x(p => sx(p[0])).y(p => sy(p[1]));

            g.append("path")
              .attr("d", path(hull) + "Z")
              .attr("fill", "none")
              .attr("stroke", "#0b2540")
              .attr("stroke-width", 1.2)
              .attr("opacity", 1);
          }
        }
      }
    }
  }
}

async function addFeature() {
  const name = (document.getElementById("feature_name").value || "").trim();
  if (!name) return;

  $("#btn_add").prop("disabled", true);

  try {
    const cached = await loadCachedDimsCellsOutput(name);
    const parsed = parseDimsCellsROutput(cached);
    featureCells.set(parsed.name, parsed.ids);
    renderChips();
    drawClusterHeatmap();
    drawHullHeatmap();
    $("#btn_add").prop("disabled", false);
    return;
  } catch (e) {
    // Cache not found / not readable — fall back to server.
    console.log("[cache miss] fallback to /rscripts/dims_cells.r:", e.message);
  }

  // 2) Fallback: call R script (needs server)
  const payload = `${fd}_${ld}_${rds_name}_${name}`;

  $.ajax({
    url: "/rscripts/dims_cells.r",
    type: "POST",
    data: payload,
    processData: false,
    contentType: "text/plain; charset=utf-8",
    success: function(respText) {
      try {
        const parsed = parseDimsCellsROutput(respText);
        featureCells.set(parsed.name, parsed.ids);
        renderChips();
        drawClusterHeatmap();
        drawHullHeatmap();
      } catch (err) {
        console.error(err);
        alert("dims_cells.R output parse failed: " + err.message);
      }
    },
    error: function(xhr) {
      console.error(xhr.responseText);
      alert("dims_cells.R error (check server log).");
    },
    complete: function() {
      $("#btn_add").prop("disabled", false);
    }
  });
}

document.getElementById("btn_add").addEventListener("click", addFeature);
document.getElementById("feature_name").addEventListener("keydown", (e)=>{ if (e.key==="Enter") addFeature(); });

Promise.all([loadDimensionsCSV(), loadClusteringsCSV()]).then(()=>{
  // initial render
  drawClusterHeatmap();
  drawHullHeatmap();
}).catch(err=>{
  console.error(err);
  alert("Failed to load CSV(s):" + err.message)
});
</script>
</body>
</html>
